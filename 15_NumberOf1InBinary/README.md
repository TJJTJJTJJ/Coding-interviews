# 二进制中1的个数

____

## 题目描述

输入一个整数，输出该数二进制表示中1的个数。例如 9 表示 1001， 有两位是1，输出2.
____

## 解法

### v-1.0

直观想法是对这个数字不停地除以2，余数就是二进制的表示，直到商为0，也就是数的二进制表示的求解。

或者遍历判断是不是1.

但问题是还需要手动求这个数字的二进制表示。

### v-2.0

将除以2改为右移一位，余数为0还是1改为整数与1做位与运算。

或者这么理解，**整数的最右边是不是1，可以通过与1做位与运算计算**。

**左移的效率要大于除法，所以对于2的除法可以考虑是否可以用左移或者右移代替**。

### v-3.0

对于**负数**，左移会补充1，增加1的个数，而且会出现一直**死循环**的情况，因为达不到终止条件，左移之后为0.

或者可以补充为左移之后为0或者左移一定的次数。

所以修改为1进行右移，做位与运算，一直到右移之后为0.避免负数左移新增加1.显然这种方法更好一些。

**对于二进制，首先考虑的是位运算**。

### v-4.0

这个真想不到。

**性质**：一个数减去1，就是最右边的1..0变成了01..1，即最右边的1变成0，1右边的0(如果有的话)变成1.那么位与运算就可以消去最右边的1，位与之后的数字作为新的数字，以此类推。正数和负数都符合这个性质。

**把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中的最右边一个1变成0**。

结束条件是当n为0.

那么时间复杂度就是二进制中1的个数。

(n - 1) & n
____

## 测试用例

1. 正数（包括边界值 1、0x7FFFFFFF）
2. 负数（包括边界值 0x80000000、0xFFFFFFFF）
3. 0

___

## 位运算

二进制的五种运算：与，或，异或，左移和右移

左移: m << n，m左移n位，填充0，表示乘以2的n次方，再对max(2的次方)求余数

右移：m >> n, m右移n位，表示除以2的n次方向下取整，其中负数填充1，其他填充0.

## 备注

为了更好的理解这个问题在 Python 中的实现，先简单介绍 Python 数值类型，需要注意 Python 2 和 Python 3 的数值类型是有些区别的。Python 2 的数值类型有 4 种类型，即 int, long, float 和 complex 。而在 Python 3 中，int 和 long 类型已经整合到一起，成为新的 int 类型，也就是说，Python 3 中，只有 3 种类型，即 int, float 和 complex。 对 bool 类型，在 Python 2 中，其是普通整型 int （at least 32 bits of precision）的子类型；在 Python 3 中，其是 int 类型（unlimited precision）的子类型。

　　Python 2 的数值类型 int 是普通整型，是有范围的，可以通过 sys.maxint 获取其最大值，至少 32 bit。当 Python 2 程序中的整数值超出范围后，自动转换为 long 类型，而 long 类型是没有范围限制的，即 unlimited precision。在 Python 3 中，这两种类型被统一起来，表示为 int 类型，与 Python 2 的数值类型 long 相同，没有范围限定（unlimited precision）。也就是说，在 Python 中，整型数是没有溢出的（overflow）。在 Python 程序中，当对一个负整数与其减 1 后的值按位求与，若结果为 0 退出，循环执行此过程。由于整型数可以有无限的数值精度，其结果永远不会是 0，如此编程，在 Python 中，只会造成死循环。而在 C/C++ 中，整数（32 bit）的范围是 [ - 2147483648, 2147483647 ]，与此相对， Python 2 中的 long 类型和 Python 3 中 int 类型，如果不指定整型数的位数，是没有范围限制的。

```python
INT_BITS = 32
MAX_INT = (1<<(INT_BITS))-1
```

-2&-3=-4
