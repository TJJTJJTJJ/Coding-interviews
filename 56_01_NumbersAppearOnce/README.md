# 数组中只出现一次的数字

____

## 题目描述

数组中只出现过一次的数字有好几个版本，所以对其进行一次小总结。

### v-1.0

在一个数组中除一个数字只出现一次之外，其他数字都出现了两次。请找出那个只出现一次的数字。

* 异或能使两个相同的数字变成0
* 0和任何数异或还是任何数
* 1和任何数异或是对任何数取反
* 两个不同的数字异或一定不为0
* 使某些特定的位翻转
* 实现两个值的交换，而不必使用临时变量

对这些数字从前到后异或，结果即为所求。

### v-2.0

在一个数组中除两个数字只出现一次之外，其他数字都出现了两次。请找出那个只出现一次的数字

对这些数字进行异或，结果中为1的那一位表示两个不同数字在这一位不同，再根据这一位是0还是1划分为0组和1组，不难得出，0组和1组是等效的v-1.0版本的数组。

### v-3.0

在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

解法：我们把数组中所有数字的二进制表示的每一位都加起来。如果某一位的和能被3整除，那么那个只出现一次的数字二进制表示中对应的那一位是0；否则就是1。这种解决方案可以扩展到其他所有数字都出现了N次的情形。

### v-4.0

找出一个数组中三个只出现一次的数字，其他数字都出现两次.

思路:x=a@b@c, y = f(x@a)@f(x@b)@f(x@c),y最后一位是1的位数为m,则只有一个数字的m位为1，其他两个数字的m位为0，可以把a,b,c分开

将所有数字异或，得到的结果为x=a@b@c。x必然与a,b,c都不相同，因此x@a,x@b,x@c都不为0.定义函数f(n)，作用是保留数字n的二进制表示中最后一位1，而其他位都变为0. 则f(x@a),f(x@b),f(x@c)的结果均不为0.考虑f(x@a)@f(x@b)@f(x@c)的结果，它肯定不为0。因为对于三个非零的数i,j,k, f(i)@f(j)的结果要么为0，要么结果的二进制结果中有两个是1，而f(k)的结果中只有一位是1，所以f(i)@f(j)@f(k)一定不为0。因此f(x@a)@f(x@b)@f(x@c)至少有一位为1，假设最后一位是1的位为第 m 位。那么x@a, x@b, x@c的结果中，有一个或者三个数字的第m位是1.下面证明不可能三个结果的第m位都是1. 反证法证明：若x@a，x@b， x@c的第m位都是1，则a,b,c的第m位都和x的第m位相反，那么a,b,c的第m位相同。若都为0，则x=a@b@c的第m为也未0，与x的第m位与a,b,c第m位相反矛盾；同样若都为1，则x第m位为1，与假设矛盾。因此a,b,c中只有一个数字的第m位为1。 于是我们找到了区分a,b,c三个数字的标准。一旦将第m位为1的数找出来之后，另外两个数字也可以找出来了。

### v-5.0

给你1-1000个连续自然数，然后从中随机去掉两个，再打乱顺序，要求只遍历一次，求出被去掉的两个数。

这两个数组(打乱前和打乱后)各自异或，也就是1^2^…^1000，得到两个异或值。再对这两个异或值进行一次异或，这样就得到了x^y的指(重复部分互相抵消了)。

### v-6.0

假设你有一个用1001个整数组成的数组，这些整数是任意排列的，但是你知道所有的整数都在1到1000(包括1000)之间。此外，除一个数字出现两次外，其他所有数字只出现一次。假设你只能对这个数组做一次处理，用一种算法找出重复的那个数字。如果你在运算中使用了辅助的存储方式，那么你能找到不用这种方式的算法吗?

方法一、若使用辅助的存储方式，该选择何种存储方式呢？可使用hash的存储方式，以1到1000作为hash表的索引，遍历原数组，统计各数字出现的个数并存储到以该数字为索引值的hash表中，若某个hash[x]的值为2则退出循环，x就是重复出现两次的数字。时间复杂度最坏是O(n)。

方法二、若不使用辅助的存储方式呢？已知1001个整数组成的数组只有一个数字出现了两次，且整数都在1到1000之间，所以可推得数组里面包含了1到1000之间的所有数字为[1,2,3……1000]和一个出现两次的x为1到1000中的任一个数字。这样就可以计算原数组里的所有数字之和S1和等差数列[1,2,3……1000]的和S2，再计算S1与S2之差，该差就是原数组中出现两次的数字x。时间复杂度是固定的O(n)。

### v-7.0

在一个长度为n的数组里的所有数组都在0～n-1的范围。数组中某些数字是重复的，但不知道有哪些数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复数字。

因为数组大小为n且元素在0~n-1，所以排序之后每个位置对应下标是自己的序号
基于排序，调整array[i] = i。

* 如果array[i] != i，观察array[i] == array[array[i]]是否成立，成立则找到了。
否则，交换array[i]和array[array[i]]；
* 如果array[i]==i, i++，如果i>=len，没有重复的数字，反之继续。

最坏情况下需要2n步，n个交换操作和n个移步操作。

____

## 解法

### v-1.0


____

## 测试用例



___

